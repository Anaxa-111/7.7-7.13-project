import cv2  # 导入 OpenCV
import numpy as np
from typing import Tuple   # 用于类型提示

def embed_watermark(image_path: str, watermark_path: str, alpha: float = 0.3) -> np.ndarray:
    """
    嵌入水印到图像中。

    Args:
        image_path:  原始图像路径。
        watermark_path:  水印图像路径。
        alpha:  水印的透明度 (0.0 - 1.0)。  值越大，水印越明显。

    Returns:
        带有水印的图像 (NumPy 数组)  如果出现错误，则返回 None。
    """
    try:
        ## 1. 读取图像
        image = cv2.imread(image_path)
        watermark = cv2.imread(watermark_path, cv2.IMREAD_UNCHANGED)  # 保持 Alpha 通道
        if image is None or watermark is None:
            print("Error: Could not read image or watermark.")
            return None

        # 2. 缩放水印到合适的大小 (保持宽高比)
        image_height, image_width = image.shape[:2]
        watermark_height, watermark_width = watermark.shape[:2]
        scale = min(image_width / watermark_width, image_height / watermark_height) * 0.2  # 水印大小，可调整
        new_width = int(watermark_width * scale)
        new_height = int(watermark_height * scale)
        watermark = cv2.resize(watermark, (new_width, new_height), interpolation=cv2.INTER_AREA)

        # 3.  处理 Alpha 通道 (如果水印图像有 Alpha 通道)
        if watermark.shape[2] == 4: # 如果有 Alpha 通道
            watermark_alpha = watermark[:, :, 3] / 255.0  # Alpha 值范围 0.0 - 1.0
            watermark_rgb = watermark[:, :, :3]  # 提取 RGB 通道
            # 4.  确保水印放置在图像范围内，这里放置在右下角
            x_offset = image_width - watermark.shape[1] - 10  # 从右侧留 10 像素间隔
            y_offset = image_height - watermark.shape[0] - 10  # 从底部留 10 像素间隔

            # 5. 叠加水印 (带 Alpha 混合)
            for c in range(0, 3): # RGB 通道
                image[y_offset:y_offset+watermark.shape[0], x_offset:x_offset+watermark.shape[1], c] = \
                    watermark_rgb[:, :, c] * watermark_alpha + image[y_offset:y_offset+watermark.shape[0], x_offset:x_offset+watermark.shape[1], c] * (1 - watermark_alpha)

        else:  # 没有 Alpha 通道
            # 4. 确保水印放置在图像范围内
             x_offset = image_width - watermark.shape[1] - 10  # 从右侧留 10 像素间隔
             y_offset = image_height - watermark.shape[0] - 10  # 从底部留 10 像素间隔
            # 5. 叠加水印
            for c in range(0, 3): # RGB 通道
                image[y_offset:y_offset+watermark.shape[0], x_offset:x_offset+watermark.shape[1], c] = \
                    watermark[:, :, c] * alpha + image[y_offset:y_offset+watermark.shape[0], x_offset:x_offset+watermark.shape[1], c] * (1 - alpha)



        return image

    except Exception as e:
        print(f"Error in embed_watermark: {e}")
        return None
